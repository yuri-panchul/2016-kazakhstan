<html>
<body>
<h3>Individual project #3
</h3><h3>Sequential design
</h3><h3>June 12, 2015
</h3><p>
</p><p>An example introductory project: Implement a design of a shift register with enable signal. The design should input a single bit from a key and put in into the shift register. The current state and the output of the shift register should be displayed on LEDs in binary representation. In addition, the current state of the shift register should be displayed on static multi-digit seven-segment display in hexadecimal form.
</p><p>
</p><p>3.1. Modify the counter design to count in decimal instead of hexadecimal. Not 0, 1, 2, ... 9, A, B, C, D, E, F, 10, 11, ... FFFF - but 0, 1, 2, ... 9, 10, 11, ... 9999, 0, 1, 2, ... Hint: you may need to add decimal digits separately and propagate carry.
</p><p>
</p><p>3.2. Modify the counter design to count signed two's complement 12-bit number backwards. Output the result in hexadecimal representation with a sign: 000, -800, -7FF, -7FE, ... -002, -001, 000, 001, 002, ... 7FF, -800, ...
</p><p>
</p><p>3.3. Modify the counter design to count with three different speeds, depending on pressed button.
</p><p>
</p><p>3.4. Modify the counter design to count either forward (0, 1, 2, ...) or backward (0, FFFF, FFFE, ... , 3, 2, 1, 0, FFFF ...), depending on pressed button.
</p><p>
</p><p>3.5. Modify the counter design to count either adding 1, or 2, or 3, depending on pressed buttons.
</p><p>
</p><p>3.6. Modify the counter design to add disable signal that pauses counting. Connect this signal to a button.
</p><p>
</p><p>3.7. Modify the counter design to count separately in each digit. Not 0000, 0001, 0002, ... FFFE, FFFF, 0000 - but 0000, 1111, 2222, 3333, ... EEEE, FFFF, 0000.
</p><p>
</p><p>3.8. Modify the counter design to count separately in each two digits - 0000, 0101, 0202, ... FEFE, FFFF, 0000.
</p><p>
</p><p>3.9. Modify the counter design to count separately in digit 3 and digits 2:0 - 0000, 1001, 2002, ... F00F, 0010, 1011, ... EFFE, FFFF, 0000.
</p><p>
</p><p>3.10. Modify the counter design to count separately in each digit with different speed: 0000, 1234, 2468, 369C, 48C0, 5AF4, ... In other words one digit 0, 1, 2, ... F, 0; second 0, 2, 4, 6, ... E, 0; third one 0, 3, 6, 9, C, F, 2, 5, 8, B, E, 1, 4, 7, A, D, 0, fourth 0, 4, 8, C, 0, ...
</p><p>
</p><p>3.11. Implement the design that generates Fibonnacci numbers: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ... The next number is found by adding up the two numbers before it.
</p><p>  
</p><p>3.12. Modify the shift register design to make LED lights moving not from left to right, but from right to left. Not 10011000, 01001100, 00100110, 00010011, 00001001, 00000100, ... - but 10011000, 00110000, 01100000, 11000000, ...
</p><p>  
</p><p>3.13. Modify the shift register design to make LED lights moving either from left to right or from right to left - depending on pressed button.
</p><p>  
</p><p>3.14. Modify the shift register design to make LED lights moving with different speed - depending on pressed button.
</p><p>  
</p><p>3.15. Modify the shift register design to make LED lights circularly: 10011000, 01001100, 00100110, 00010011, 10001001, 11000100, 01100010, 00110001, 10011000, ... Use one button as input, and a second button as input enable.
</p><p>  
</p><p>3.16. Modify the shift register design to make LED lights moving circularly and either from left to right or from right to left - depending on pressed button. Use one button as input, second button as input enable, and third button to control the direction of movement.
</p><p>  
</p><p>3.17. Modify the shift register design by splitting it into two independent 4-bit wide shift registers, with inputs coming from two different buttons.
</p><p>  
</p><p>3.18. Modify the shift register design by splitting it into two independent 4-bit wide shift registers, with inputs coming from the same button and with different speeds of shifting. The first should shift with the speed of one bit per clock cycle, the second - with the speed of two bits per clock cycle.
</p><p>  
</p><p>3.19. Modify the shift register design by splitting it into two independent 4-bit wide shift registers, with inputs coming from the same button and with different speeds of shifting. The first should shift with the speed of one bit per clock cycle, the second - with the speed of one bit every other cycle.
</p><p>  
</p><p>3.20. Implement a variant of exercise (18) with circular movements of LED lights. Use one button as input, and a second button as input enable.
</p><p>
</p><p>3.21. Implement a variant of exercise (19) with circular movements of LED lights. Use one button as input, and a second button as input enable.
</p><p>  
</p><p>3.22. Implement a variant of exercise (18) with LEDs connected to the first shift register moving from left to right and LEDs connected to another one - from right to left.
</p><p>  
</p><p>3.23. Implement a variant of exercise (19) with LEDs connected to the first shift register moving from left to right and LEDs connected to another one - from right to left.
</p><p>  
</p><p>3.24. Implement a variant of exercise (22) with circular movements of LED lights. Use one button as input, and a second button as input enable.
</p><p>  
</p><p>3.25. Implement a variant of exercise (23) with circular movements of LED lights. Use one button as input, and a second button as input enable.
</p><p>  
</p><p>3.26. Modify the state machine design below by counting the occurrences of "01" sequences (i.e. counting the number of event when moore_out and mealy_out asserted). Output the number of moore_out events to the digits 3:2 of seven-segment display and the number of mealy_out events to the digits 1:0 of seven-segment display.
</p><p>  
</p><p>3.27. Modify the state machine design below to recognize the sequences of "0101" instead of "01". You need to implement only Moore machine.
</p><p>  
</p><p>3.28. Modify the state machine design below to recognize the sequences of "010101" instead of "01". You need to implement only Mealy machine.
</p><p>  
</p><p>3.29. Implement a variant of exercise 27 where you count the number of sequences instead of just recognizing them. Output the value of the counter to seven-segment display.
</p><p>  
</p><p>3.30. Implement a variant of exercise 28 where you count the number of sequences instead of just recognizing them. Output the value of the counter to seven-segment display.
</p><p>
</p><p>Additional:
</p><p>
</p><p>3.31. Implement a variant of exercise 26 with fast clock (using 50 MHz clk instead of 1.49 Hz clock) for the shift register and state machines. When you press the input button once, the design may detect several "01" sequences because of bouncing. Try different buttons and switches on FPGA board as inputs. Report the results - are you able to detect bouncing?
</p><p>  
</p><p>3.32. A variant of exercise 31 modified to recognize the sequences of "0101" instead of "01". You need to implement only Moore machine.
</p><p>  
</p><p>3.33. A variant of exercise 31 modified to recognize the sequences of "010101" instead of "01". You need to implement only Mealy machine.
</p><p>  
</p><p>3.34. Modify the counter design to use ripple-carry adder built using logical operations instead of the adder created by synthesizing Verilog "+" operation.
</p><p>  
</p><p>3.35. Modify the counter design to use carry-lookahead adder built using logical operations instead of the adder created by synthesizing Verilog "+" operation.
</p><p>
</p><p>
</p><p>
<hr>
<pre>

Reference materials:

//--------------------------------------------------------------------

</pre>
</body>
</html>
