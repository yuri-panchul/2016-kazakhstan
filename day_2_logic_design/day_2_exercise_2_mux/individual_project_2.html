<html>
<body>
<h3>Individual project #2
</h3><h3>Combinational design - multiplexor
</h3><h3>June 12, 2015
</h3><p>
</p><p>An example design below, implemented on Basys 3 board, implements various multiplexers in different ways. Using this design as a guideline, implement the following multiplexer:
</p><p>
</p><p>
</p><p>2.1. Implement 16-to-1 multiplexer using "?:" Verilog operator.
</p><p>
</p><p>2.2. Implement 16-to-1 multiplexer using "if" statement.
</p><p>
</p><p>2.3. Implement 16-to-1 multiplexer using "case" statement.
</p><p>
</p><p>2.4. Implement 16-to-1 multiplexer by instantiating two 8-to-1 multiplexers and one 2-to-1 multiplexer. Implement both 8-to-1 and 2-to-1 multiplexer modules using "?:" Verilog operator.
</p><p>
</p><p>2.5. Implement 16-to-1 multiplexer by instantiating two 8-to-1 multiplexers and one 2-to-1 multiplexer. Implement both 8-to-1 and 2-to-1 multiplexer modules using "if" statement.
</p><p>
</p><p>2.6. Implement 16-to-1 multiplexer by instantiating two 8-to-1 multiplexers and one 2-to-1 multiplexer. Implement both 8-to-1 and 2-to-1 multiplexer modules using "case" statement.
</p><p>
</p><p>2.7. Implement 16-to-1 multiplexer by instantiating five 4-to-1 multiplexers. Implement 4-to-1 multiplexer module using "?:" Verilog operator.
</p><p>
</p><p>2.8. Implement 16-to-1 multiplexer by instantiating five 4-to-1 multiplexers. Implement 4-to-1 multiplexer module using "if" statement.
</p><p>
</p><p>2.9. Implement 16-to-1 multiplexer by instantiating five 4-to-1 multiplexers. Implement 4-to-1 multiplexer module using "case" statement.
</p><p>
</p><p>2.10. Implement 16-to-1 multiplexer by instantiating 15 2-to-1 multiplexers. Implement 2-to-1 multiplexer module using "?:" Verilog operator.
</p><p>
</p><p>2.11. Implement 16-to-1 multiplexer by instantiating 15 2-to-1 multiplexers. Implement 2-to-1 multiplexer module using "if" statement.
</p><p>
</p><p>2.12. Implement 16-to-1 multiplexer by instantiating 15 2-to-1 multiplexers. Implement 2-to-1 multiplexer module using "case" statement.
</p><p>
</p><p>2.13. Implement 2-bit wide 8-to-1 multiplexer using "?:" Verilog operator.
</p><p>
</p><p>2.14. Implement 2-bit wide 8-to-1 multiplexer using "if" statement.
</p><p>
</p><p>2.15. Implement 2-bit wide 8-to-1 multiplexer using "case" statement.
</p><p>
</p><p>2.16. Implement 2-bit wide 8-to-1 multiplexer by instantiating two 2-bit wide 4-to-1 multiplexers and one 2-bit wide 2-to-1 multiplexer. Implement both 4-to-1 and 2-to-1 multiplexer modules using "?:" Verilog operator.
</p><p>
</p><p>2.17. Implement 2-bit wide 8-to-1 multiplexer by instantiating two 2-bit wide 4-to-1 multiplexers and one 2-bit wide 2-to-1 multiplexer. Implement both 4-to-1 and 2-to-1 multiplexer modules using "if" statement.
</p><p>
</p><p>2.18. Implement 2-bit wide 8-to-1 multiplexer by instantiating two 2-bit wide 4-to-1 multiplexers and one 2-bit wide 2-to-1 multiplexer. Implement both 4-to-1 and 2-to-1 multiplexer modules using "case" statement.
</p><p>
</p><p>2.19. Implement 2-bit wide 8-to-1 multiplexer by instantiating seven 2-bit wide 2-to-1 multiplexers. Implement 2-to-1 multiplexer module using "?:" Verilog operator.
</p><p>
</p><p>2.20. Implement 2-bit wide 8-to-1 multiplexer by instantiating seven 2-bit wide 2-to-1 multiplexers. Implement 2-to-1 multiplexer module using "if" statement.
</p><p>
</p><p>2.21. Implement 2-bit wide 8-to-1 multiplexer by instantiating seven 2-bit wide 2-to-1 multiplexers. Implement 2-to-1 multiplexer module using "case" statement.
</p><p>
</p><p>2.22. Implement 2-bit wide 8-to-1 multiplexer by instantiating two 1-bit wide 8-to-1 multiplexers. Implement 1-bit wide 8-to-1 multiplexer module using "?:" Verilog operator.
</p><p>
</p><p>2.23. Implement 2-bit wide 8-to-1 multiplexer by instantiating two 1-bit wide 8-to-1 multiplexers. Implement 1-bit wide 8-to-1 multiplexer module using "if" statement.
</p><p>
</p><p>2.24. Implement 2-bit wide 8-to-1 multiplexer by instantiating two 1-bit wide 8-to-1 multiplexers. Implement 1-bit wide 8-to-1 multiplexer module using "case" statement.
</p><p>
</p><p>2.25. Implement 2-bit wide 8-to-1 multiplexer by instantiating two 1-bit wide 8-to-1 multiplexers. Implement 1-bit wide 8-to-1 multiplexer module by instantiating two 1-bit wide 4-to-1 multiplexers and one 1-bit wide 2-to-1 multiplexer. Implement both 4-to-1 and 2-to-1 multiplexer modules using "?:" Verilog operator.
</p><p>
</p><p>2.26. Implement 2-bit wide 8-to-1 multiplexer by instantiating two 1-bit wide 8-to-1 multiplexers. Implement 1-bit wide 8-to-1 multiplexer module by instantiating two 1-bit wide 4-to-1 multiplexers and one 1-bit wide 2-to-1 multiplexer. Implement both 4-to-1 and 2-to-1 multiplexer modules using "if" statement.
</p><p>
</p><p>2.27. Implement 2-bit wide 8-to-1 multiplexer by instantiating two 1-bit wide 8-to-1 multiplexers. Implement 1-bit wide 8-to-1 multiplexer module by instantiating two 1-bit wide 4-to-1 multiplexers and one 1-bit wide 2-to-1 multiplexer. Implement both 4-to-1 and 2-to-1 multiplexer modules using "case" statement.
</p><p>
</p><p>2.28. Implement 2-bit wide 8-to-1 multiplexer by instantiating two 1-bit wide 8-to-1 multiplexers. Implement 1-bit wide 8-to-1 multiplexer module by instantiating seven 1-bit wide 2-to-1 multiplexers. Implement 2-to-1 multiplexer module using "?:" Verilog operator.
</p><p>
</p><p>2.29. Implement 2-bit wide 8-to-1 multiplexer by instantiating two 1-bit wide 8-to-1 multiplexers. Implement 1-bit wide 8-to-1 multiplexer module by instantiating seven 1-bit wide 2-to-1 multiplexers. Implement 2-to-1 multiplexer module using "if" statement.
</p><p>
</p><p>2.30. Implement 2-bit wide 8-to-1 multiplexer by instantiating two 1-bit wide 8-to-1 multiplexers. Implement 1-bit wide 8-to-1 multiplexer module by instantiating seven 1-bit wide 2-to-1 multiplexers. Implement 2-to-1 multiplexer module using "case" statement.
</p><p>
</p><p>
</p>
<hr>
<pre>
module mux_2_1
(
    input  [3:0] d0,
    input  [3:0] d1,
    input        sel,
    output [3:0] y
);

    assign y = sel ? d1 : d0;

endmodule

module mux_4_1_imp_1
(
    input  [3:0] d0, d1, d2, d3,
    input  [1:0] sel,
    output [3:0] y
);

    assign y = sel [1]
        ? (sel [0] ? d3 : d2)
        : (sel [0] ? d1 : d0);

endmodule

module mux_4_1_imp_2
(
    input      [3:0] d0, d1, d2, d3,
    input      [1:0] sel,
    output reg [3:0] y
);

    always @*
        case (sel)
        2'b00: y = d0;
        2'b01: y = d1;
        2'b10: y = d2;
        2'b11: y = d3;
        endcase

endmodule

module mux_4_1_imp_3
(
    input  [3:0] d0, d1, d2, d3,
    input  [1:0] sel,
    output [3:0] y
);

    wire [3:0] w01, w23;

    mux_2_1 i0 (.d0 ( d0  ), .d1 ( d1  ), .sel (sel [0]), .y ( w01 ));
    mux_2_1 i1 (.d0 ( d2  ), .d1 ( d3  ), .sel (sel [0]), .y ( w23 ));
    mux_2_1 i2 (.d0 ( w01 ), .d1 ( w23 ), .sel (sel [1]), .y ( y   ));

endmodule

module mux_4_1_bits_2
(
    input  [1:0] d0, d1, d2, d3,
    input  [1:0] sel,
    output [1:0] y
);

    assign y = sel [1]
        ? (sel [0] ? d3 : d2)
        : (sel [0] ? d1 : d0);

endmodule

module mux_4_1_imp_4
(
    input  [3:0] d0, d1, d2, d3,
    input  [1:0] sel,
    output [3:0] y
);

    mux_4_1_bits_2 high
    (
        .d0  ( d0 [3:2] ),
        .d1  ( d1 [3:2] ),
        .d2  ( d2 [3:2] ),
        .d3  ( d3 [3:2] ),
        .sel ( sel      ),
        .y   ( y  [3:2] )
    );

    mux_4_1_bits_2 low
    (
        .d0  ( d0 [1:0] ),
        .d1  ( d1 [1:0] ),
        .d2  ( d2 [1:0] ),
        .d3  ( d3 [1:0] ),
        .sel ( sel      ),
        .y   ( y  [1:0] )
    );

endmodule

module basys3_2
(
    input         clk,

    input         btnC,
    input         btnU,
    input         btnL,
    input         btnR,
    input         btnD,

    input  [15:0] sw,

    output [15:0] led,

    output [ 6:0] seg,
    output        dp,
    output [ 3:0] an
);

    mux_4_1_imp_1
    (
        .d0  ( sw  [ 3: 0]    ),
        .d1  ( sw  [ 7: 4]    ),
        .d2  ( sw  [11: 8]    ),
        .d3  ( sw  [15:12]    ),
        .sel ( { btnC, btnR } ),
        .y   ( led [ 3: 0]    )
    ); 
        
    mux_4_1_imp_2
    (
        .d0  ( sw  [ 3: 0]    ),
        .d1  ( sw  [ 7: 4]    ),
        .d2  ( sw  [11: 8]    ),
        .d3  ( sw  [15:12]    ),
        .sel ( { btnC, btnR } ),
        .y   ( led [ 7: 4]    )
    ); 
        
    mux_4_1_imp_3
    (
        .d0  ( sw  [ 3: 0]    ),
        .d1  ( sw  [ 7: 4]    ),
        .d2  ( sw  [11: 8]    ),
        .d3  ( sw  [15:12]    ),
        .sel ( { btnC, btnR } ),
        .y   ( led [11: 8]    )
    ); 

    mux_4_1_imp_4
    (
        .d0  ( sw  [ 3: 0]    ),
        .d1  ( sw  [ 7: 4]    ),
        .d2  ( sw  [11: 8]    ),
        .d3  ( sw  [15:12]    ),
        .sel ( { btnC, btnR } ),
        .y   ( led [15:12]    )
    ); 

    assign seg = ~ 7'b0;
    assign dp  = 1'b1;
    assign an  = 4'b0;

endmodule
</pre>
</body>
</html>
